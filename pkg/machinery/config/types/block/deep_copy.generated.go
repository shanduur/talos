// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// Code generated by "deep-copy -type ExistingVolumeConfigV1Alpha1 -type RawVolumeConfigV1Alpha1 -type SwapVolumeConfigV1Alpha1 -type UserVolumeConfigV1Alpha1 -type VolumeConfigV1Alpha1 -type ZswapConfigV1Alpha1 -pointer-receiver -header-file ../../../../../hack/boilerplate.txt -o deep_copy.generated.go ."; DO NOT EDIT.

package block

// DeepCopy generates a deep copy of *ExistingVolumeConfigV1Alpha1.
func (o *ExistingVolumeConfigV1Alpha1) DeepCopy() *ExistingVolumeConfigV1Alpha1 {
	var cp ExistingVolumeConfigV1Alpha1 = *o
	if o.MountSpec.MountReadOnly != nil {
		cp.MountSpec.MountReadOnly = new(bool)
		*cp.MountSpec.MountReadOnly = *o.MountSpec.MountReadOnly
	}
	return &cp
}

// DeepCopy generates a deep copy of *RawVolumeConfigV1Alpha1.
func (o *RawVolumeConfigV1Alpha1) DeepCopy() *RawVolumeConfigV1Alpha1 {
	var cp RawVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.ps = *o.ProvisioningSpec.ProvisioningMinSize.ps
		if o.ProvisioningSpec.ProvisioningMinSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.ps.value = *o.ProvisioningSpec.ProvisioningMinSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.ps.raw, o.ProvisioningSpec.ProvisioningMinSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMinSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.bs = *o.ProvisioningSpec.ProvisioningMinSize.bs
		if o.ProvisioningSpec.ProvisioningMinSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.bs.value = *o.ProvisioningSpec.ProvisioningMinSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.bs.raw, o.ProvisioningSpec.ProvisioningMinSize.bs.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ps = *o.ProvisioningSpec.ProvisioningMaxSize.ps
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = *o.ProvisioningSpec.ProvisioningMaxSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw, o.ProvisioningSpec.ProvisioningMaxSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.bs = *o.ProvisioningSpec.ProvisioningMaxSize.bs
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = *o.ProvisioningSpec.ProvisioningMaxSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw, o.ProvisioningSpec.ProvisioningMaxSize.bs.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *SwapVolumeConfigV1Alpha1.
func (o *SwapVolumeConfigV1Alpha1) DeepCopy() *SwapVolumeConfigV1Alpha1 {
	var cp SwapVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.ps = *o.ProvisioningSpec.ProvisioningMinSize.ps
		if o.ProvisioningSpec.ProvisioningMinSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.ps.value = *o.ProvisioningSpec.ProvisioningMinSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.ps.raw, o.ProvisioningSpec.ProvisioningMinSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMinSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.bs = *o.ProvisioningSpec.ProvisioningMinSize.bs
		if o.ProvisioningSpec.ProvisioningMinSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.bs.value = *o.ProvisioningSpec.ProvisioningMinSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.bs.raw, o.ProvisioningSpec.ProvisioningMinSize.bs.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ps = *o.ProvisioningSpec.ProvisioningMaxSize.ps
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = *o.ProvisioningSpec.ProvisioningMaxSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw, o.ProvisioningSpec.ProvisioningMaxSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.bs = *o.ProvisioningSpec.ProvisioningMaxSize.bs
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = *o.ProvisioningSpec.ProvisioningMaxSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw, o.ProvisioningSpec.ProvisioningMaxSize.bs.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *UserVolumeConfigV1Alpha1.
func (o *UserVolumeConfigV1Alpha1) DeepCopy() *UserVolumeConfigV1Alpha1 {
	var cp UserVolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.ps = *o.ProvisioningSpec.ProvisioningMinSize.ps
		if o.ProvisioningSpec.ProvisioningMinSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.ps.value = *o.ProvisioningSpec.ProvisioningMinSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.ps.raw, o.ProvisioningSpec.ProvisioningMinSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMinSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.bs = *o.ProvisioningSpec.ProvisioningMinSize.bs
		if o.ProvisioningSpec.ProvisioningMinSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.bs.value = *o.ProvisioningSpec.ProvisioningMinSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.bs.raw, o.ProvisioningSpec.ProvisioningMinSize.bs.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ps = *o.ProvisioningSpec.ProvisioningMaxSize.ps
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = *o.ProvisioningSpec.ProvisioningMaxSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw, o.ProvisioningSpec.ProvisioningMaxSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.bs = *o.ProvisioningSpec.ProvisioningMaxSize.bs
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = *o.ProvisioningSpec.ProvisioningMaxSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw, o.ProvisioningSpec.ProvisioningMaxSize.bs.raw)
		}
	}
	if o.FilesystemSpec.ProjectQuotaSupportConfig != nil {
		cp.FilesystemSpec.ProjectQuotaSupportConfig = new(bool)
		*cp.FilesystemSpec.ProjectQuotaSupportConfig = *o.FilesystemSpec.ProjectQuotaSupportConfig
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *VolumeConfigV1Alpha1.
func (o *VolumeConfigV1Alpha1) DeepCopy() *VolumeConfigV1Alpha1 {
	var cp VolumeConfigV1Alpha1 = *o
	if o.ProvisioningSpec.ProvisioningGrow != nil {
		cp.ProvisioningSpec.ProvisioningGrow = new(bool)
		*cp.ProvisioningSpec.ProvisioningGrow = *o.ProvisioningSpec.ProvisioningGrow
	}
	if o.ProvisioningSpec.ProvisioningMinSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.ps = *o.ProvisioningSpec.ProvisioningMinSize.ps
		if o.ProvisioningSpec.ProvisioningMinSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.ps.value = *o.ProvisioningSpec.ProvisioningMinSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.ps.raw, o.ProvisioningSpec.ProvisioningMinSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMinSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMinSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMinSize.bs = *o.ProvisioningSpec.ProvisioningMinSize.bs
		if o.ProvisioningSpec.ProvisioningMinSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMinSize.bs.value = *o.ProvisioningSpec.ProvisioningMinSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMinSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMinSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMinSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMinSize.bs.raw, o.ProvisioningSpec.ProvisioningMinSize.bs.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.ps != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.ps = new(PercentageSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.ps = *o.ProvisioningSpec.ProvisioningMaxSize.ps
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.ps.value = *o.ProvisioningSpec.ProvisioningMaxSize.ps.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.ps.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.ps.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.ps.raw, o.ProvisioningSpec.ProvisioningMaxSize.ps.raw)
		}
	}
	if o.ProvisioningSpec.ProvisioningMaxSize.bs != nil {
		cp.ProvisioningSpec.ProvisioningMaxSize.bs = new(ByteSize)
		*cp.ProvisioningSpec.ProvisioningMaxSize.bs = *o.ProvisioningSpec.ProvisioningMaxSize.bs
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.value != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = new(uint64)
			*cp.ProvisioningSpec.ProvisioningMaxSize.bs.value = *o.ProvisioningSpec.ProvisioningMaxSize.bs.value
		}
		if o.ProvisioningSpec.ProvisioningMaxSize.bs.raw != nil {
			cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw = make([]byte, len(o.ProvisioningSpec.ProvisioningMaxSize.bs.raw))
			copy(cp.ProvisioningSpec.ProvisioningMaxSize.bs.raw, o.ProvisioningSpec.ProvisioningMaxSize.bs.raw)
		}
	}
	if o.EncryptionSpec.EncryptionKeys != nil {
		cp.EncryptionSpec.EncryptionKeys = make([]EncryptionKey, len(o.EncryptionSpec.EncryptionKeys))
		copy(cp.EncryptionSpec.EncryptionKeys, o.EncryptionSpec.EncryptionKeys)
		for i3 := range o.EncryptionSpec.EncryptionKeys {
			if o.EncryptionSpec.EncryptionKeys[i3].KeyStatic != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = new(EncryptionKeyStatic)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyStatic = *o.EncryptionSpec.EncryptionKeys[i3].KeyStatic
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = new(EncryptionKeyNodeID)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyNodeID = *o.EncryptionSpec.EncryptionKeys[i3].KeyNodeID
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyKMS != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = new(EncryptionKeyKMS)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyKMS = *o.EncryptionSpec.EncryptionKeys[i3].KeyKMS
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = new(EncryptionKeyTPM)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = new(EncryptionKeyTPMOptions)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions
					if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs != nil {
						cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs = make([]int, len(o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs))
						copy(cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs, o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMOptions.PCRs)
					}
				}
				if o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll != nil {
					cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = new(bool)
					*cp.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll = *o.EncryptionSpec.EncryptionKeys[i3].KeyTPM.TPMCheckSecurebootStatusOnEnroll
				}
			}
			if o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE != nil {
				cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = new(bool)
				*cp.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE = *o.EncryptionSpec.EncryptionKeys[i3].KeyLockToSTATE
			}
		}
	}
	if o.EncryptionSpec.EncryptionPerfOptions != nil {
		cp.EncryptionSpec.EncryptionPerfOptions = make([]string, len(o.EncryptionSpec.EncryptionPerfOptions))
		copy(cp.EncryptionSpec.EncryptionPerfOptions, o.EncryptionSpec.EncryptionPerfOptions)
	}
	return &cp
}

// DeepCopy generates a deep copy of *ZswapConfigV1Alpha1.
func (o *ZswapConfigV1Alpha1) DeepCopy() *ZswapConfigV1Alpha1 {
	var cp ZswapConfigV1Alpha1 = *o
	if o.MaxPoolPercentConfig != nil {
		cp.MaxPoolPercentConfig = new(int)
		*cp.MaxPoolPercentConfig = *o.MaxPoolPercentConfig
	}
	if o.ShrinkerEnabledConfig != nil {
		cp.ShrinkerEnabledConfig = new(bool)
		*cp.ShrinkerEnabledConfig = *o.ShrinkerEnabledConfig
	}
	return &cp
}
